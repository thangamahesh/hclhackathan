package com.hcl.wallet.service.impl;

import com.hcl.wallet.dto.wallet.*;
import com.hcl.wallet.exception.InsufficientFundsException;
import com.hcl.wallet.exception.WalletNotFound;
import com.hcl.wallet.model.Currency;
import com.hcl.wallet.model.Customer;
import com.hcl.wallet.model.Transactions;
import com.hcl.wallet.model.Wallet;
import com.hcl.wallet.repository.TransactionsRepository;
import com.hcl.wallet.repository.WalletRepository;
import com.hcl.wallet.service.WalletService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class WalletServiceImpl implements WalletService {

    private final WalletRepository walletRepository;
    private final TransactionsRepository transactionsRepository;

    @Override
    @Transactional
    public WalletResponse createWallet(CreateWalletRequest request) {
        Customer customer = new Customer();
        customer.setCustomerId(request.getCustomerId());
        Currency currency = new Currency();
        currency.setCurrencyCode(request.getCurrencyCode());
        Wallet wallet = Wallet.builder()
                // walletId is expected to be generated by DB; keep null
                .walletId(request.getWalletId())
                .customer(customer) // association should be set by lookup; keep null for minimal implementation
                .currency(currency)
                .balanceMinor(amountToMinor(request.getInitialBalance()))
                .status("ACTIVE")
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
        Wallet saved = walletRepository.save(wallet);
        return toResponse(saved);
    }

    @Override
    public WalletResponse getWallet(Long walletId) {
        Wallet w = walletRepository.findById(walletId)
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + walletId));
        return toResponse(w);
    }

    @Override
    public WalletResponse getWalletByCustomer(Long customerId) {
        Wallet w = walletRepository.findByCustomer_CustomerId(customerId)
                .orElseThrow(() -> new WalletNotFound("Wallet not found for customer: " + customerId));
        return toResponse(w);
    }

    @Override
    @Transactional
    public BalanceResponse getBalance(Long walletId) {
        Wallet w = walletRepository.findById(walletId)
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + walletId));
        return BalanceResponse.builder()
                .balance(minorToAmount(w.getBalanceMinor()))
                .currencyCode(w.getCurrency() != null ? w.getCurrency().getCurrencyCode() : "")
                .build();
    }

    @Override
    @Transactional
    public WalletResponse deposit(Long walletId, DepositRequest request) {
        Wallet w = walletRepository.findByWalletId(walletId)
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + walletId));
        long add = amountToMinor(request.getAmount());
        w.setBalanceMinor(w.getBalanceMinor() + add);
        w.setUpdatedAt(LocalDateTime.now());
        Transactions txn = Transactions.builder()
                .transactionId(null)
                .wallet(w)
                .merchant(null)
                .product(null)
                .txnAmount(add)
                .currency(w.getCurrency())
                .customer(w.getCustomer())
                .txnType("DEPOSIT")
                .status("SUCCESS")
                .initiator(request.getInitiator() == null ? "SYSTEM" : request.getInitiator())
                .createdAt(LocalDateTime.now())
                .completedAt(LocalDateTime.now())
                .build();
        transactionsRepository.save(txn);
        Wallet saved = walletRepository.save(w);
        return toResponse(saved);
    }

    @Override
    @Transactional
    public WalletResponse withdraw(Long walletId, WithdrawRequest request) {
        Wallet w = walletRepository.findByWalletId(walletId)
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + walletId));
        long sub = amountToMinor(request.getAmount());
        if (w.getBalanceMinor() < sub) {
            throw new InsufficientFundsException("Insufficient balance");
        }
        w.setBalanceMinor(w.getBalanceMinor() - sub);
        w.setUpdatedAt(LocalDateTime.now());
        Transactions txn = Transactions.builder()
                .transactionId(null)
                .wallet(w)
                .merchant(null)
                .product(null)
                .txnAmount(sub)
                .currency(w.getCurrency())
                .customer(w.getCustomer())
                .txnType("WITHDRAW")
                .status("SUCCESS")
                .initiator(request.getInitiator() == null ? "SYSTEM" : request.getInitiator())
                .createdAt(LocalDateTime.now())
                .completedAt(LocalDateTime.now())
                .build();
        transactionsRepository.save(txn);
        Wallet saved = walletRepository.save(w);
        return toResponse(saved);
    }

    @Override
    @Transactional
    public TransferResponse transfer(TransferRequest request) {
        if (request.getFromWalletId().equals(request.getToWalletId())) {
            throw new RuntimeException("Cannot transfer to same wallet");
        }
        Wallet from = walletRepository.findByWalletId(request.getFromWalletId())
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + request.getFromWalletId()));
        Wallet to = walletRepository.findByWalletId(request.getToWalletId())
                .orElseThrow(() -> new WalletNotFound("Wallet not found: " + request.getToWalletId()));
        long amt = amountToMinor(request.getAmount());
        if (from.getBalanceMinor() < amt) {
            throw new InsufficientFundsException("Insufficient balance");
        }
        from.setBalanceMinor(from.getBalanceMinor() - amt);
        to.setBalanceMinor(to.getBalanceMinor() + amt);
        from.setUpdatedAt(LocalDateTime.now());
        to.setUpdatedAt(LocalDateTime.now());

        Transactions txnFrom = Transactions.builder()
                .transactionId(null)
                .wallet(from)
                .merchant(null)
                .product(null)
                .txnAmount(amt)
                .currency(from.getCurrency())
                .customer(from.getCustomer())
                .txnType("TRANSFER_OUT")
                .status("SUCCESS")
                .initiator(request.getInitiator() == null ? "SYSTEM" : request.getInitiator())
                .createdAt(LocalDateTime.now())
                .completedAt(LocalDateTime.now())
                .build();
        Transactions txnTo = Transactions.builder()
                .transactionId(null)
                .wallet(to)
                .merchant(null)
                .product(null)
                .txnAmount(amt)
                .currency(to.getCurrency())
                .customer(to.getCustomer())
                .txnType("TRANSFER_IN")
                .status("SUCCESS")
                .initiator(request.getInitiator() == null ? "SYSTEM" : request.getInitiator())
                .createdAt(LocalDateTime.now())
                .completedAt(LocalDateTime.now())
                .build();
        transactionsRepository.save(txnFrom);
        transactionsRepository.save(txnTo);
        walletRepository.save(from);
        walletRepository.save(to);
        return TransferResponse.builder()
                .fromWallet(toResponse(from))
                .toWallet(toResponse(to))
                .build();
    }

    private WalletResponse toResponse(Wallet w) {
        return WalletResponse.builder()
                .walletId(w.getWalletId())
                .customerId(w.getCustomer() != null ? w.getCustomer().getCustomerId() : null)
                .currencyCode(w.getCurrency() != null ? w.getCurrency().getCurrencyCode() : null)
                .balance(minorToAmount(w.getBalanceMinor()))
                .status(w.getStatus())
                .createdAt(w.getCreatedAt())
                .updatedAt(w.getUpdatedAt())
                .build();
    }

    private long amountToMinor(BigDecimal amount) {
        if (amount == null) return 0L;
        return amount.multiply(new BigDecimal(100)).longValue();
    }

    private java.math.BigDecimal minorToAmount(Long minor) {
        if (minor == null) return java.math.BigDecimal.ZERO;
        return new java.math.BigDecimal(minor).divide(new java.math.BigDecimal(100));
    }
}

